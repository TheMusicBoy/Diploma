\isubsection{Архитектура ORM}

    \isubsubsection{Инверсия зависимостей между ООП и реляционными моделями}
    
        Суть ORM заключается в инверсии зависимостей между объектно-ориентированной моделью и реляционной моделью данных. Это фундаментальный принцип, позволяющий разрешить объектно-реляционное несоответствие импеданса.
        
        В объектно-ориентированном программировании данные представлены в виде сложных графовых структур объектов, обладающих:
        
        \begin{itemize}
            \item \textbf{Иерархиями наследования} — классы образуют древовидные или сетевые структуры;
            \item \textbf{Инкапсуляцией внутреннего состояния} — данные скрыты и доступны только через методы;
            \item \textbf{Полиморфизмом и динамическим поведением} — объекты могут менять поведение во время выполнения;
            \item \textbf{Разнообразными связями между объектами} — отношения 1:1, 1:N, M:N реализованные через ссылки;
            \item \textbf{Сложными типами данных} — композиция объектов внутри других объектов.
        \end{itemize}
        
        В реляционной модели данные организованы в таблицы с плоской структурой, связанные через ключи, с акцентом на:
        
        \begin{itemize}
            \item \textbf{Нормализацию данных} — разделение данных для устранения избыточности;
            \item \textbf{Ссылочную целостность} — обеспечение корректности связей через внешние ключи;
            \item \textbf{Атомарные типы данных} — хранение простых типов в ячейках таблиц;
            \item \textbf{Операции реляционной алгебры} — манипуляция данными через JOIN, SELECT, PROJECT и другие.
        \end{itemize}
        
        ORM инвертирует традиционный процесс разработки, позволяя разработчикам:
        
        \begin{itemize}
            \item Проектировать приложение, основываясь на объектной модели;
            \item Работать с объектами, как естественными сущностями вашего домена;
            \item Делегировать ORM трансформацию между объектным и реляционным представлениями.
        \end{itemize}

    \isubsubsection{Мое решение}
    
        Разрабатываемая ORM будет иметь модульную архитектуру из трех основных компонентов:
        
        \textbf{1. Ядро ORM}
        
            Этот компонент является центральным элементом системы и отвечает за:
            
            \begin{itemize}
                \item \textbf{Объектно-реляционное отображение:} автоматическое преобразование между объектами и таблицами;
                
                \item \textbf{Сессии и единицы работы:} отслеживание изменений в загруженных объектах;
                
                \item \textbf{Идентификационное отображение:} сохранение и восстановление идентичности объектов;
                
                \item \textbf{Ленивую загрузку:} отложенная загрузка связанных объектов;
                
                \item \textbf{Типобезопасные запросы:} DSL для построения запросов в объектно-ориентированном стиле.
            \end{itemize}
            
            Ядро будет использовать метаданные, сгенерированные из Protocol Buffers схем, для корректного отображения объектов на таблицы.
        
        \textbf{2. Master}
        
            Master служит интерфейсом между ядром ORM и базами данных:
            
            \begin{itemize}
                \item \textbf{Генерация SQL:} трансляция объектно-ориентированных запросов в оптимизированный SQL;
                
                \item \textbf{Управление соединениями:} пулы соединений и транзакций с БД;
                
                \item \textbf{Диалекты SQL:} адаптация запросов под особенности конкретных СУБД;
                
                \item \textbf{Преобразование данных:} маппинг между типами C++ и типами БД;
                
                \item \textbf{Обработка больших объемов данных:} пакетные операции и потоковая обработка.
            \end{itemize}
            
            Master абстрагирует ядро ORM от специфики конкретных СУБД и обеспечивает эффективное выполнение запросов.
        
        \textbf{3. Migrator}
        
            Migrator автоматизирует эволюцию схемы базы данных:
            
            \begin{itemize}
                \item \textbf{Создание и обновление схем:} автоматическая генерация DDL-скриптов;
                
                \item \textbf{Версионирование:} управление версиями схемы БД;
                
                \item \textbf{Дифференциальный анализ:} выявление изменений в схеме между версиями;
                
                \item \textbf{Безопасные миграции:} обеспечение сохранности данных при изменении схемы;
                
                \item \textbf{Интеграция с CI/CD:} автоматизация миграций в процессе развертывания.
            \end{itemize}
            
            Migrator обеспечивает синхронизацию между объектной моделью приложения и реляционной схемой БД.

    \isubsubsection{Взаимодействие компонентов}
    
        В работающей системе данные компоненты взаимодействуют следующим образом:
        
        \begin{itemize}
            \item \textbf{Разработчик} определяет объектную модель с помощью Protocol Buffers;
            
            \item \textbf{Migrator} анализирует модель и создает/обновляет схему БД;
            
            \item \textbf{Ядро ORM} предоставляет API для работы с объектами;
            
            \item \textbf{Master} транслирует операции в SQL и взаимодействует с БД;
            
            \item \textbf{Ядро ORM} преобразует результаты в объекты для использования в приложении.
        \end{itemize}
        
        Эта архитектура обеспечивает полное разделение между объектной моделью приложения и реляционной моделью БД, позволяя каждой развиваться независимо, но сохраняя их синхронизацию.

    \isubsubsection{Методы оптимизации запросов}
    
        Эффективность ORM-решения критически зависит от производительности выполнения запросов к базе данных. В разрабатываемой архитектуре будут реализованы следующие методы оптимизации:
        
        \textbf{1. Объединение запросов (Query Batching)}
        
            Объединение запросов позволяет значительно снизить накладные расходы на взаимодействие с БД:
            
            \begin{itemize}
                \item \textbf{N+1 проблема:} автоматическое выявление и решение проблемы N+1 запросов путем замены серии отдельных запросов на один эффективный запрос;
                
                \item \textbf{Пакетная загрузка связанных объектов:} оптимизация загрузки отношений 1:N и M:N через объединенные запросы с IN-предикатами;
                
                \item \textbf{Пакетные операции вставки/обновления:} группировка операций изменения данных в одной транзакции с использованием bulk-операций.
            \end{itemize}
            
            Пример оптимизации N+1 проблемы:
            
            \begin{lstlisting}[style=cpp_style]
// Стандартный: N+1 запрос
std::vector<User> users = session.query<User>().all();
for (auto& user : users) {
    // Отдельный запрос для каждого пользователя
    user.roles = session.query<Role>().where("user_id = ?", user.id).all();
}

// Оптимизированный: 2 запроса
std::vector<User> users = session.query<User>().all();
std::vector<int> userIds;
for (const auto& user : users) {
    userIds.push_back(user.id);
}
auto rolesMap = session.query<Role>()
    .where("user_id IN ({})", userIds)
    .groupBy([](const Role& role) { return role.userId; })
    .all();
for (auto& user : users) {
    user.roles = rolesMap[user.id];
}
            \end{lstlisting}
        
        \textbf{2. Ленивая и жадная загрузка}
        
            ORM будет поддерживать различные стратегии загрузки данных:
            
            \begin{itemize}
                \item \textbf{Ленивая загрузка (Lazy Loading):} загрузка связанных объектов только при первом обращении к ним, что уменьшает начальное потребление памяти;
                
                \item \textbf{Жадная загрузка (Eager Loading):} предварительная загрузка связанных объектов в одном запросе, уменьшающая общее количество обращений к БД;
                
                \item \textbf{Условная загрузка:} настраиваемые правила для выбора между ленивой и жадной стратегиями в зависимости от контекста.
            \end{itemize}
        
        \textbf{3. Компиляция запросов}
        
            Для максимальной производительности критичных запросов будет использоваться компиляция запросов во время сборки:
            
            \begin{itemize}
                \item \textbf{Статический анализ:} проверка корректности запросов на этапе компиляции;
                
                \item \textbf{Предкомпиляция:} генерация оптимизированного кода для часто используемых запросов;
                
                \item \textbf{Параметризованные запросы:} повторное использование скомпилированных планов выполнения.
            \end{itemize}
        
        \textbf{4. Оптимизация на уровне SQL}
        
            Master будет применять ряд оптимизаций при генерации SQL:
            
            \begin{itemize}
                \item \textbf{Минимизация выборки:} выбор только необходимых полей вместо использования SELECT *;
                
                \item \textbf{Оптимизация JOIN:} анализ и оптимизация порядка и типов соединений таблиц;
            \end{itemize}
            
        Комбинирование всех этих методов оптимизации позволит достичь высокой производительности при сохранении удобства использования ORM. Особое внимание будет уделено оптимизациям, специфичным для C++, таким как эффективное управление памятью, минимизация копирований данных и использование возможностей компиляции.
